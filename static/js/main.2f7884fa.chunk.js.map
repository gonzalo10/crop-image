{"version":3,"sources":["utils.js","image-crop.js","index.js"],"names":["getClientPos","e","pageX","pageY","touches","x","y","clamp","num","min","max","Math","isCropValid","crop","width","height","isNaN","inverseOrd","ord","convertToPercentCrop","imageWidth","imageHeight","unit","aspect","convertToPixelCrop","CropSelectionWrapper","styled","div","props","circularCrop","CropImageWrapper","img","passiveSupported","window","addEventListener","Object","defineProperty","get","err","ReactCrop","document","state","onCropAreaMouseDown","disabled","mediaDimensions","pixelCrop","preventDefault","clientPos","componentRef","focus","preventScroll","cropOffset","target","dataset","xInversed","yInversed","getElementOffset","cropSelectRef","evData","clientStartX","clientStartY","cropStartWidth","cropStartHeight","cropStartX","cropStartY","xCrossOver","yCrossOver","startXCrossOver","startYCrossOver","isResize","mouseDownOnCropArea","setState","cropIsActive","onComponentMouseDown","console","log","locked","keepSelection","onChange","componentEl","mediaWrapperRef","firstChild","contains","mediaOffset","mouseXPosInImage","left","mouseYPosInImage","top","nextCrop","undefined","newCropIsBeingDrawn","onDocMouseMove","onDragStart","dragStarted","straightenYPath","xDiff","yDiff","resizeCrop","dragCrop","onDocMouseTouchEnd","onComplete","onDragEnd","onMediaLoaded","createNewCrop","percentCrop","this","options","passive","onDocMouseTouchMove","addEventListeners","removeEventListener","removeEventListeners","prevProps","resolvedCrop","fixedCrop","widthOverflows","heightOverflows","resolveCrop","makeNewCrop","image","onImageLoaded","documentElement","clientTop","clientLeft","pageYOffset","pageXOffset","el","rect","getBoundingClientRect","doc","getDocumentOffset","win","getWindowOffset","newHeight","minWidth","maxWidth","minHeight","maxHeight","newWidth","abs","xDiffPc","yDiffPc","newSize","getNewSize","newX","newY","lastYCrossover","containedCrop","prevCrop","prevPixelCrop","contained","adjustedForX","adjustedForY","containCrop","xyOrds","indexOf","xOrds","yOrds","crossOverCheck","clientX","k","d","ruleOfThirds","style","getCropStyle","ref","r","onMouseDown","onTouchStart","tabIndex","className","data-ord","Fragment","defaultCrop","swapXOrd","swapYOrd","inversedXOrd","inversedYOrd","children","crossorigin","imageAlt","onImageError","renderComponent","src","imageStyle","cropSelection","createCropSelection","componentClasses","clsx","n","imageRef","crossOrigin","onLoad","onImageLoad","onError","alt","clientWidth","clientHeight","PureComponent","nudgeStep","nudgeStepLarge","defaultProps","renderSelectionAddon","App","onSelectFile","files","length","reader","FileReader","result","readAsDataURL","onCropComplete","makeClientCrop","onCropChange","getCroppedImg","croppedImageUrl","fileName","canvas","createElement","scaleX","naturalWidth","scaleY","naturalHeight","getContext","drawImage","Promise","resolve","reject","toBlob","blob","name","URL","revokeObjectURL","fileUrl","createObjectURL","error","type","accept","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.2f7884fa.chunk.js","sourcesContent":["export const addEventListeners = (\n\tdocument,\n\tonDocMouseTouchMove,\n\tonDocMouseTouchEnd,\n\tcomponentRef,\n\tonMediaLoaded,\n\toptions\n) => {\n\tdocument.addEventListener('mousemove', onDocMouseTouchMove, options);\n\tdocument.addEventListener('touchmove', onDocMouseTouchMove, options);\n\tdocument.addEventListener('mouseup', onDocMouseTouchEnd, options);\n\tdocument.addEventListener('touchend', onDocMouseTouchEnd, options);\n\tdocument.addEventListener('touchcancel', onDocMouseTouchEnd, options);\n\tcomponentRef.addEventListener('medialoaded', onMediaLoaded);\n};\nexport const removeEventListeners = (\n\tdocument,\n\tonDocMouseTouchMove,\n\tonDocMouseTouchEnd,\n\tcomponentRef,\n\tonMediaLoaded\n) => {\n\tdocument.removeEventListener('mousemove', onDocMouseTouchMove);\n\tdocument.removeEventListener('touchmove', onDocMouseTouchMove);\n\tdocument.removeEventListener('mouseup', onDocMouseTouchEnd);\n\tdocument.removeEventListener('touchend', onDocMouseTouchEnd);\n\tdocument.removeEventListener('touchcancel', onDocMouseTouchEnd);\n\tcomponentRef.removeEventListener('medialoaded', onMediaLoaded);\n};\n\nexport function getClientPos(e) {\n\tlet pageX;\n\tlet pageY;\n\n\tif (e.touches) {\n\t\t[{ pageX, pageY }] = e.touches;\n\t} else {\n\t\t({ pageX, pageY } = e);\n\t}\n\n\treturn {\n\t\tx: pageX,\n\t\ty: pageY,\n\t};\n}\n\nexport function clamp(num, min, max) {\n\treturn Math.min(Math.max(num, min), max);\n}\n\nexport function isCropValid(crop) {\n\treturn (\n\t\tcrop &&\n\t\tcrop.width &&\n\t\tcrop.height &&\n\t\t!isNaN(crop.width) &&\n\t\t!isNaN(crop.height)\n\t);\n}\n\nexport function inverseOrd(ord) {\n\tif (ord === 'n') return 's';\n\tif (ord === 'ne') return 'sw';\n\tif (ord === 'e') return 'w';\n\tif (ord === 'se') return 'nw';\n\tif (ord === 's') return 'n';\n\tif (ord === 'sw') return 'ne';\n\tif (ord === 'w') return 'e';\n\tif (ord === 'nw') return 'se';\n\treturn ord;\n}\n\nexport function convertToPercentCrop(crop, imageWidth, imageHeight) {\n\tif (crop.unit === '%') {\n\t\treturn crop;\n\t}\n\n\treturn {\n\t\tunit: '%',\n\t\taspect: crop.aspect,\n\t\tx: (crop.x / imageWidth) * 100,\n\t\ty: (crop.y / imageHeight) * 100,\n\t\twidth: (crop.width / imageWidth) * 100,\n\t\theight: (crop.height / imageHeight) * 100,\n\t};\n}\n\nexport function convertToPixelCrop(crop, imageWidth, imageHeight) {\n\tif (!crop.unit) {\n\t\treturn { ...crop, unit: 'px' };\n\t}\n\n\tif (crop.unit === 'px') {\n\t\treturn crop;\n\t}\n\n\treturn {\n\t\tunit: 'px',\n\t\taspect: crop.aspect,\n\t\tx: (crop.x * imageWidth) / 100,\n\t\ty: (crop.y * imageHeight) / 100,\n\t\twidth: (crop.width * imageWidth) / 100,\n\t\theight: (crop.height * imageHeight) / 100,\n\t};\n}\n\nexport function resolveCrop(pixelCrop, imageWidth, imageHeight) {\n\tif (!pixelCrop) {\n\t\treturn pixelCrop;\n\t}\n\n\tlet fixedCrop = pixelCrop;\n\tconst widthOverflows = pixelCrop.x + pixelCrop.width > imageWidth;\n\tconst heightOverflows = pixelCrop.y + pixelCrop.height > imageHeight;\n\n\tif (widthOverflows && heightOverflows) {\n\t\tfixedCrop = {\n\t\t\tunit: 'px',\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: imageWidth > pixelCrop.width ? pixelCrop.width : imageWidth,\n\t\t\theight: imageHeight > pixelCrop.height ? pixelCrop.height : imageHeight,\n\t\t};\n\t} else if (widthOverflows) {\n\t\tfixedCrop = {\n\t\t\t...pixelCrop,\n\t\t\tx: 0,\n\t\t\twidth: imageWidth > pixelCrop.width ? pixelCrop.width : imageWidth,\n\t\t};\n\t} else if (heightOverflows) {\n\t\tfixedCrop = {\n\t\t\t...pixelCrop,\n\t\t\ty: 0,\n\t\t\theight: imageHeight > pixelCrop.height ? pixelCrop.height : imageHeight,\n\t\t};\n\t}\n\n\treturn fixedCrop;\n}\n\nexport function containCrop(prevCrop, crop, imageWidth, imageHeight) {\n\tconst pixelCrop = convertToPixelCrop(crop, imageWidth, imageHeight);\n\tconst prevPixelCrop = convertToPixelCrop(prevCrop, imageWidth, imageHeight);\n\tconst contained = { ...pixelCrop };\n\n\t// Non-aspects are simple\n\tif (!pixelCrop.aspect) {\n\t\tif (pixelCrop.x < 0) {\n\t\t\tcontained.x = 0;\n\t\t\tcontained.width += pixelCrop.x;\n\t\t} else if (pixelCrop.x + pixelCrop.width > imageWidth) {\n\t\t\tcontained.width = imageWidth - pixelCrop.x;\n\t\t}\n\n\t\tif (pixelCrop.y + pixelCrop.height > imageHeight) {\n\t\t\tcontained.height = imageHeight - pixelCrop.y;\n\t\t}\n\n\t\treturn contained;\n\t}\n\n\tlet adjustedForX = false;\n\n\tif (pixelCrop.x < 0) {\n\t\tcontained.x = 0;\n\t\tcontained.width += pixelCrop.x;\n\t\tcontained.height = contained.width / pixelCrop.aspect;\n\t\tadjustedForX = true;\n\t} else if (pixelCrop.x + pixelCrop.width > imageWidth) {\n\t\tcontained.width = imageWidth - pixelCrop.x;\n\t\tcontained.height = contained.width / pixelCrop.aspect;\n\t\tadjustedForX = true;\n\t}\n\n\t// If sizing in up direction we need to pin Y at the point it\n\t// would be at the boundary.\n\tif (adjustedForX && prevPixelCrop.y > contained.y) {\n\t\tcontained.y = pixelCrop.y + (pixelCrop.height - contained.height);\n\t}\n\n\tlet adjustedForY = false;\n\n\tif (contained.y + contained.height > imageHeight) {\n\t\tcontained.height = imageHeight - pixelCrop.y;\n\t\tcontained.width = contained.height * pixelCrop.aspect;\n\t\tadjustedForY = true;\n\t}\n\n\t// If sizing in left direction we need to pin X at the point it\n\t// would be at the boundary.\n\tif (adjustedForY && prevPixelCrop.x > contained.x) {\n\t\tcontained.x = pixelCrop.x + (pixelCrop.width - contained.width);\n\t}\n\n\treturn contained;\n}\n","import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport styled from 'styled-components';\n\nimport {\n\tgetClientPos,\n\tclamp,\n\tisCropValid,\n\tinverseOrd,\n\tconvertToPercentCrop,\n\tconvertToPixelCrop,\n\tresolveCrop,\n\tcontainCrop,\n\taddEventListeners,\n\tremoveEventListeners,\n} from './utils';\n\nconst CropSelectionWrapper = styled.div`\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\ttransform: translate3d(0, 0, 0);\n\tbox-sizing: border-box;\n\tcursor: move;\n\tbox-shadow: 0 0 0 9999em rgba(0, 0, 0, 0.5);\n\ttouch-action: manipulation;\n\tborder: 1px solid;\n\tborder-image-source: url('data:image/gif;base64,R0lGODlhCgAKAJECAAAAAP///////wAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEI5RDc5MTFDNkE2MTFFM0JCMDZEODI2QTI4MzJBOTIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEI5RDc5MTBDNkE2MTFFM0JCMDZEODI2QTI4MzJBOTIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuZGlkOjAyODAxMTc0MDcyMDY4MTE4MDgzQzNDMjA5MzREQ0ZDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAyODAxMTc0MDcyMDY4MTE4MDgzQzNDMjA5MzREQ0ZDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEBQoAAgAsAAAAAAoACgAAAhWEERkn7W3ei7KlagMWF/dKgYeyGAUAIfkEBQoAAgAsAAAAAAoACgAAAg+UYwLJ7RnQm7QmsCyVKhUAIfkEBQoAAgAsAAAAAAoACgAAAhCUYgLJHdiinNSAVfOEKoUCACH5BAUKAAIALAAAAAAKAAoAAAIRVISAdusPo3RAzYtjaMIaUQAAIfkEBQoAAgAsAAAAAAoACgAAAg+MDiem7Q8bSLFaG5il6xQAIfkEBQoAAgAsAAAAAAoACgAAAg+UYRLJ7QnQm7SmsCyVKhUAIfkEBQoAAgAsAAAAAAoACgAAAhCUYBLJDdiinNSEVfOEKoECACH5BAUKAAIALAAAAAAKAAoAAAIRFISBdusPo3RBzYsjaMIaUQAAOw==');\n\tborder-image-slice: 1;\n\tborder-image-repeat: repeat;\n\t${props =>\n\t\tprops.circularCrop &&\n\t\t`border-radius: 50%;\n\tbox-shadow: 0px 0px 1px 1px white, 0 0 0 9999em rgba(0, 0, 0, 0.5);`}\n`;\n\nconst CropImageWrapper = styled.img`\n\tposition: relative;\n\tdisplay: inline-block;\n\tcursor: crosshair;\n\toverflow: hidden;\n\tmax-width: 100%;\n\t&:focus {\n\t\toutline: none;\n\t}\n\tdisplay: block;\n\tmax-width: 100%;\n\ttouch-action: manipulation;\n`;\n\nlet passiveSupported = false;\n\ntry {\n\twindow.addEventListener(\n\t\t'test',\n\t\tnull,\n\t\tObject.defineProperty({}, 'passive', {\n\t\t\tget: () => {\n\t\t\t\tpassiveSupported = true;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t})\n\t);\n} catch (err) {} // eslint-disable-line no-empty\n\nclass ReactCrop extends PureComponent {\n\twindow = typeof window !== 'undefined' ? window : {};\n\n\tdocument = typeof document !== 'undefined' ? document : {};\n\n\tstate = {};\n\n\tcomponentDidMount() {\n\t\tif (this.document.addEventListener) {\n\t\t\tconst options = passiveSupported ? { passive: false } : false;\n\t\t\taddEventListeners(\n\t\t\t\tthis.document,\n\t\t\t\tthis.onDocMouseMove,\n\t\t\t\tthis.onDocMouseTouchEnd,\n\t\t\t\tthis.componentRef,\n\t\t\t\tthis.onMediaLoaded,\n\t\t\t\toptions\n\t\t\t);\n\t\t}\n\t}\n\n\tcomponentWillUnmount() {\n\t\tif (this.document.removeEventListener)\n\t\t\tremoveEventListeners(\n\t\t\t\tthis.document,\n\t\t\t\tthis.onDocMouseMove,\n\t\t\t\tthis.onDocMouseTouchEnd,\n\t\t\t\tthis.componentRef,\n\t\t\t\tthis.onMediaLoaded\n\t\t\t);\n\t}\n\n\tcomponentDidUpdate(prevProps) {\n\t\t//Dont know what this does\n\t\t// const { onChange, onComplete, crop } = this.props;\n\t\t// if (prevProps.crop !== crop && this.imageRef) {\n\t\t// \tconst { width, height } = this.imageRef;\n\t\t// \tconst crop = this.makeNewCrop();\n\t\t// \tconst resolvedCrop = resolveCrop(crop, width, height);\n\t\t// \tif (crop !== resolvedCrop) {\n\t\t// \t\tconsole.log('corp!==resolvedCrop');\n\t\t// \t\tconst pixelCrop = convertToPixelCrop(resolvedCrop, width, height);\n\t\t// \t\tconst percentCrop = convertToPercentCrop(resolvedCrop, width, height);\n\t\t// \t\tonChange(pixelCrop, percentCrop);\n\t\t// \t\tonComplete(pixelCrop, percentCrop);\n\t\t// \t}\n\t\t// }\n\t}\n\n\tonCropAreaMouseDown = e => {\n\t\t// console.log('onCropAreaMouseDown');\n\t\tconst { crop, disabled } = this.props;\n\t\tconst { width, height } = this.mediaDimensions;\n\t\tconst pixelCrop = convertToPixelCrop(crop, width, height);\n\n\t\tif (disabled) {\n\t\t\treturn;\n\t\t}\n\t\te.preventDefault(); // Stop drag selection.\n\n\t\tconst clientPos = getClientPos(e);\n\n\t\t// Focus for detecting keypress.\n\t\tthis.componentRef.focus({ preventScroll: true });\n\t\tconst { ord } = e.target.dataset;\n\t\tconst xInversed = ord === 'nw' || ord === 'w' || ord === 'sw';\n\t\tconst yInversed = ord === 'nw' || ord === 'n' || ord === 'ne';\n\n\t\tlet cropOffset;\n\n\t\tif (pixelCrop.aspect) {\n\t\t\tcropOffset = this.getElementOffset(this.cropSelectRef);\n\t\t}\n\n\t\tthis.evData = {\n\t\t\tclientStartX: clientPos.x,\n\t\t\tclientStartY: clientPos.y,\n\t\t\tcropStartWidth: pixelCrop.width,\n\t\t\tcropStartHeight: pixelCrop.height,\n\t\t\tcropStartX: xInversed ? pixelCrop.x + pixelCrop.width : pixelCrop.x,\n\t\t\tcropStartY: yInversed ? pixelCrop.y + pixelCrop.height : pixelCrop.y,\n\t\t\txInversed,\n\t\t\tyInversed,\n\t\t\txCrossOver: xInversed,\n\t\t\tyCrossOver: yInversed,\n\t\t\tstartXCrossOver: xInversed,\n\t\t\tstartYCrossOver: yInversed,\n\t\t\tisResize: e.target.dataset.ord,\n\t\t\tord,\n\t\t\tcropOffset,\n\t\t};\n\n\t\tthis.mouseDownOnCropArea = true;\n\t\tthis.setState({ cropIsActive: true });\n\t};\n\n\tonComponentMouseDown = e => {\n\t\tconsole.log('onComponentMouseDown');\n\t\tconst { crop, disabled, locked, keepSelection, onChange } = this.props;\n\n\t\t// firstChild to get the wrapping div and not the image\n\t\tconst componentEl = this.mediaWrapperRef.firstChild;\n\n\t\tif (e.target !== componentEl || !componentEl.contains(e.target)) return;\n\t\tif (disabled || locked || (keepSelection && isCropValid(crop))) return;\n\n\t\te.preventDefault(); // Stop drag selection.\n\n\t\tconst clientPos = getClientPos(e);\n\n\t\t// Focus for detecting keypress.\n\t\tthis.componentRef.focus({ preventScroll: true });\n\n\t\tconst mediaOffset = this.getElementOffset(this.mediaWrapperRef);\n\t\tconst mouseXPosInImage = clientPos.x - mediaOffset.left;\n\t\tconst mouseYPosInImage = clientPos.y - mediaOffset.top;\n\n\t\tconst nextCrop = {\n\t\t\tunit: 'px',\n\t\t\taspect: crop ? crop.aspect : undefined,\n\t\t\tx: mouseXPosInImage,\n\t\t\ty: mouseYPosInImage,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\n\t\tthis.evData = {\n\t\t\tclientStartX: clientPos.x,\n\t\t\tclientStartY: clientPos.y,\n\t\t\tcropStartWidth: nextCrop.width,\n\t\t\tcropStartHeight: nextCrop.height,\n\t\t\tcropStartX: nextCrop.x,\n\t\t\tcropStartY: nextCrop.y,\n\t\t\txInversed: false,\n\t\t\tyInversed: false,\n\t\t\txCrossOver: false,\n\t\t\tyCrossOver: false,\n\t\t\tstartXCrossOver: false,\n\t\t\tstartYCrossOver: false,\n\t\t\tisResize: true,\n\t\t\tord: 'nw',\n\t\t};\n\n\t\tthis.mouseDownOnCropArea = true;\n\n\t\tconst { width, height } = this.mediaDimensions;\n\n\t\tonChange(\n\t\t\tconvertToPixelCrop(nextCrop, width, height),\n\t\t\tconvertToPercentCrop(nextCrop, width, height)\n\t\t);\n\n\t\tthis.setState({ cropIsActive: true, newCropIsBeingDrawn: true });\n\t};\n\n\tonDocMouseMove = e => {\n\t\tconsole.log('onDocMouseMove');\n\t\tconst { crop, disabled, onChange, onDragStart } = this.props;\n\n\t\tif (disabled) return;\n\n\t\tif (!this.mouseDownOnCropArea) return;\n\n\t\te.preventDefault(); // Stop drag selection.\n\n\t\tif (!this.dragStarted) {\n\t\t\tthis.dragStarted = true;\n\t\t\tonDragStart(e);\n\t\t}\n\n\t\tconst { evData } = this;\n\t\tconst clientPos = getClientPos(e);\n\n\t\tif (evData.isResize && crop.aspect && evData.cropOffset) {\n\t\t\tclientPos.y = this.straightenYPath(clientPos.x);\n\t\t}\n\t\tevData.xDiff = clientPos.x - evData.clientStartX;\n\t\tevData.yDiff = clientPos.y - evData.clientStartY;\n\n\t\tlet nextCrop;\n\n\t\tif (evData.isResize) nextCrop = this.resizeCrop();\n\t\telse nextCrop = this.dragCrop();\n\n\t\tif (nextCrop !== crop) {\n\t\t\tconst { width, height } = this.mediaDimensions;\n\t\t\tonChange(\n\t\t\t\tconvertToPixelCrop(nextCrop, width, height),\n\t\t\t\tconvertToPercentCrop(nextCrop, width, height)\n\t\t\t);\n\t\t}\n\t};\n\n\tonDocMouseTouchEnd = e => {\n\t\tconst { crop, disabled, onComplete, onDragEnd } = this.props;\n\n\t\tif (disabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.mouseDownOnCropArea) {\n\t\t\tthis.mouseDownOnCropArea = false;\n\t\t\tthis.dragStarted = false;\n\n\t\t\tconst { width, height } = this.mediaDimensions;\n\n\t\t\tonDragEnd(e);\n\t\t\tonComplete(\n\t\t\t\tconvertToPixelCrop(crop, width, height),\n\t\t\t\tconvertToPercentCrop(crop, width, height)\n\t\t\t);\n\n\t\t\tthis.setState({ cropIsActive: false, newCropIsBeingDrawn: false });\n\t\t}\n\t};\n\n\t// When the image is loaded or when a custom component via `renderComponent` prop fires\n\t// a custom \"medialoaded\" event.\n\tcreateNewCrop() {\n\t\tconst { width, height } = this.mediaDimensions;\n\t\tconst crop = this.makeNewCrop();\n\t\tconst resolvedCrop = resolveCrop(crop, width, height);\n\t\tconst pixelCrop = convertToPixelCrop(resolvedCrop, width, height);\n\t\tconst percentCrop = convertToPercentCrop(resolvedCrop, width, height);\n\t\treturn { pixelCrop, percentCrop };\n\t}\n\n\t// Custom components (using `renderComponent`) should fire a custom event\n\t// called \"medialoaded\" when they are loaded.\n\tonMediaLoaded = () => {\n\t\tconst { onComplete, onChange } = this.props;\n\t\tconst { pixelCrop, percentCrop } = this.createNewCrop();\n\t\tonChange(pixelCrop, percentCrop);\n\t\tonComplete(pixelCrop, percentCrop);\n\t};\n\n\t// this is to create a cropArea as soon as so load the image\n\tonImageLoad(image) {\n\t\tconst { onComplete, onChange, onImageLoaded } = this.props;\n\n\t\t// Return false from onImageLoaded if you set the crop with setState in there as otherwise\n\t\t// the subsequent onChange + onComplete will not have your updated crop.\n\t\tconst res = onImageLoaded(image);\n\n\t\tif (res !== false) {\n\t\t\tconst { pixelCrop, percentCrop } = this.createNewCrop();\n\t\t\tonChange(pixelCrop, percentCrop);\n\t\t\tonComplete(pixelCrop, percentCrop);\n\t\t}\n\t}\n\n\tget mediaDimensions() {\n\t\tconst { clientWidth, clientHeight } = this.mediaWrapperRef;\n\t\treturn { width: clientWidth, height: clientHeight };\n\t}\n\n\tgetDocumentOffset() {\n\t\tconst { clientTop = 0, clientLeft = 0 } =\n\t\t\tthis.document.documentElement || {};\n\t\treturn { clientTop, clientLeft };\n\t}\n\n\tgetWindowOffset() {\n\t\tconst { pageYOffset = 0, pageXOffset = 0 } = this.window;\n\t\treturn { pageYOffset, pageXOffset };\n\t}\n\n\tgetElementOffset(el) {\n\t\tconst rect = el.getBoundingClientRect();\n\t\tconst doc = this.getDocumentOffset();\n\t\tconst win = this.getWindowOffset();\n\n\t\tconst top = rect.top + win.pageYOffset - doc.clientTop;\n\t\tconst left = rect.left + win.pageXOffset - doc.clientLeft;\n\n\t\treturn { top, left };\n\t}\n\n\tgetCropStyle() {\n\t\tconst crop = this.makeNewCrop(\n\t\t\tthis.props.crop ? this.props.crop.unit : 'px'\n\t\t);\n\n\t\treturn {\n\t\t\ttop: `${crop.y}${crop.unit}`,\n\t\t\tleft: `${crop.x}${crop.unit}`,\n\t\t\twidth: `${crop.width}${crop.unit}`,\n\t\t\theight: `${crop.height}${crop.unit}`,\n\t\t};\n\t}\n\n\tgetNewSize() {\n\t\tconst { crop, minWidth, maxWidth, minHeight, maxHeight } = this.props;\n\t\tconst { evData } = this;\n\t\tconst { width, height } = this.mediaDimensions;\n\n\t\t// New width.\n\t\tlet newWidth = evData.cropStartWidth + evData.xDiff;\n\n\t\tif (evData.xCrossOver) {\n\t\t\tnewWidth = Math.abs(newWidth);\n\t\t}\n\n\t\tnewWidth = clamp(newWidth, minWidth, maxWidth || width);\n\n\t\t// New height.\n\t\tlet newHeight;\n\n\t\tif (crop.aspect) {\n\t\t\tnewHeight = newWidth / crop.aspect;\n\t\t} else {\n\t\t\tnewHeight = evData.cropStartHeight + evData.yDiff;\n\t\t}\n\n\t\tif (evData.yCrossOver) {\n\t\t\t// Cap if polarity is inversed and the height fills the y space.\n\t\t\tnewHeight = Math.min(Math.abs(newHeight), evData.cropStartY);\n\t\t}\n\n\t\tnewHeight = clamp(newHeight, minHeight, maxHeight || height);\n\n\t\tif (crop.aspect) {\n\t\t\tnewWidth = clamp(newHeight * crop.aspect, 0, width);\n\t\t}\n\n\t\treturn {\n\t\t\twidth: newWidth,\n\t\t\theight: newHeight,\n\t\t};\n\t}\n\n\tdragCrop() {\n\t\tconst nextCrop = this.makeNewCrop();\n\t\tconst { evData } = this;\n\t\tconst { width, height } = this.mediaDimensions;\n\n\t\tnextCrop.x = clamp(\n\t\t\tevData.cropStartX + evData.xDiff,\n\t\t\t0,\n\t\t\twidth - nextCrop.width\n\t\t);\n\t\tnextCrop.y = clamp(\n\t\t\tevData.cropStartY + evData.yDiff,\n\t\t\t0,\n\t\t\theight - nextCrop.height\n\t\t);\n\n\t\treturn nextCrop;\n\t}\n\n\tresizeCrop() {\n\t\tconst { evData } = this;\n\t\tconst nextCrop = this.makeNewCrop();\n\t\tconst { ord } = evData;\n\n\t\t// On the inverse change the diff so it's the same and\n\t\t// the same algo applies.\n\t\tif (evData.xInversed) {\n\t\t\tevData.xDiff -= evData.cropStartWidth * 2;\n\t\t\tevData.xDiffPc -= evData.cropStartWidth * 2;\n\t\t}\n\t\tif (evData.yInversed) {\n\t\t\tevData.yDiff -= evData.cropStartHeight * 2;\n\t\t\tevData.yDiffPc -= evData.cropStartHeight * 2;\n\t\t}\n\n\t\t// New size.\n\t\tconst newSize = this.getNewSize();\n\n\t\t// Adjust x/y to give illusion of 'staticness' as width/height is increased\n\t\t// when polarity is inversed.\n\t\tlet newX = evData.cropStartX;\n\t\tlet newY = evData.cropStartY;\n\n\t\tif (evData.xCrossOver) {\n\t\t\tnewX = nextCrop.x + (nextCrop.width - newSize.width);\n\t\t}\n\n\t\tif (evData.yCrossOver) {\n\t\t\t// This not only removes the little \"shake\" when inverting at a diagonal, but for some\n\t\t\t// reason y was way off at fast speeds moving sw->ne with fixed aspect only, I couldn't\n\t\t\t// figure out why.\n\t\t\tif (evData.lastYCrossover === false) {\n\t\t\t\tnewY = nextCrop.y - newSize.height;\n\t\t\t} else {\n\t\t\t\tnewY = nextCrop.y + (nextCrop.height - newSize.height);\n\t\t\t}\n\t\t}\n\n\t\tconst { width, height } = this.mediaDimensions;\n\t\tconst containedCrop = containCrop(\n\t\t\tthis.props.crop,\n\t\t\t{\n\t\t\t\tunit: nextCrop.unit,\n\t\t\t\tx: newX,\n\t\t\t\ty: newY,\n\t\t\t\twidth: newSize.width,\n\t\t\t\theight: newSize.height,\n\t\t\t\taspect: nextCrop.aspect,\n\t\t\t},\n\t\t\twidth,\n\t\t\theight\n\t\t);\n\n\t\t// Apply x/y/width/height changes depending on ordinate (fixed aspect always applies both).\n\t\tif (nextCrop.aspect || ReactCrop.xyOrds.indexOf(ord) > -1) {\n\t\t\tnextCrop.x = containedCrop.x;\n\t\t\tnextCrop.y = containedCrop.y;\n\t\t\tnextCrop.width = containedCrop.width;\n\t\t\tnextCrop.height = containedCrop.height;\n\t\t} else if (ReactCrop.xOrds.indexOf(ord) > -1) {\n\t\t\tnextCrop.x = containedCrop.x;\n\t\t\tnextCrop.width = containedCrop.width;\n\t\t} else if (ReactCrop.yOrds.indexOf(ord) > -1) {\n\t\t\tnextCrop.y = containedCrop.y;\n\t\t\tnextCrop.height = containedCrop.height;\n\t\t}\n\n\t\tevData.lastYCrossover = evData.yCrossOver;\n\t\tthis.crossOverCheck();\n\n\t\treturn nextCrop;\n\t}\n\n\tstraightenYPath(clientX) {\n\t\tconst { evData } = this;\n\t\tconst { ord } = evData;\n\t\tconst { cropOffset, cropStartWidth, cropStartHeight } = evData;\n\t\tlet k;\n\t\tlet d;\n\n\t\tif (ord === 'nw' || ord === 'se') {\n\t\t\tk = cropStartHeight / cropStartWidth;\n\t\t\td = cropOffset.top - cropOffset.left * k;\n\t\t} else {\n\t\t\tk = -cropStartHeight / cropStartWidth;\n\t\t\td = cropOffset.top + (cropStartHeight - cropOffset.left * k);\n\t\t}\n\n\t\treturn k * clientX + d;\n\t}\n\n\tcreateCropSelection() {\n\t\tconst { disabled, locked, ruleOfThirds } = this.props;\n\t\tconst style = this.getCropStyle();\n\n\t\treturn (\n\t\t\t<CropSelectionWrapper\n\t\t\t\tref={r => (this.cropSelectRef = r)}\n\t\t\t\tstyle={style}\n\t\t\t\tonMouseDown={this.onCropAreaMouseDown}\n\t\t\t\tonTouchStart={this.onCropAreaMouseDown}\n\t\t\t\ttabIndex='0'>\n\t\t\t\t{!disabled && !locked && (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<div className='ReactCrop__drag-bar ord-n' data-ord='n' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-bar ord-e' data-ord='e' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-bar ord-s' data-ord='s' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-bar ord-w' data-ord='w' />\n\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-nw' data-ord='nw' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-n' data-ord='n' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-ne' data-ord='ne' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-e' data-ord='e' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-se' data-ord='se' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-s' data-ord='s' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-sw' data-ord='sw' />\n\t\t\t\t\t\t<div className='ReactCrop__drag-handle ord-w' data-ord='w' />\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t\t{ruleOfThirds && (\n\t\t\t\t\t<React.Fragment>\n\t\t\t\t\t\t<div className='ReactCrop__rule-of-thirds-hz' />\n\t\t\t\t\t\t<div className='ReactCrop__rule-of-thirds-vt' />\n\t\t\t\t\t</React.Fragment>\n\t\t\t\t)}\n\t\t\t</CropSelectionWrapper>\n\t\t);\n\t}\n\n\tmakeNewCrop(unit = 'px') {\n\t\tconst crop = { ...ReactCrop.defaultCrop, ...this.props.crop };\n\t\tconst { width, height } = this.mediaDimensions;\n\n\t\treturn unit === 'px'\n\t\t\t? convertToPixelCrop(crop, width, height)\n\t\t\t: convertToPercentCrop(crop, width, height);\n\t}\n\n\tcrossOverCheck() {\n\t\tconst { evData } = this;\n\t\tconst { minWidth, minHeight } = this.props;\n\n\t\tif (\n\t\t\t!minWidth &&\n\t\t\t((!evData.xCrossOver &&\n\t\t\t\t-Math.abs(evData.cropStartWidth) - evData.xDiff >= 0) ||\n\t\t\t\t(evData.xCrossOver &&\n\t\t\t\t\t-Math.abs(evData.cropStartWidth) - evData.xDiff <= 0))\n\t\t) {\n\t\t\tevData.xCrossOver = !evData.xCrossOver;\n\t\t}\n\n\t\tif (\n\t\t\t!minHeight &&\n\t\t\t((!evData.yCrossOver &&\n\t\t\t\t-Math.abs(evData.cropStartHeight) - evData.yDiff >= 0) ||\n\t\t\t\t(evData.yCrossOver &&\n\t\t\t\t\t-Math.abs(evData.cropStartHeight) - evData.yDiff <= 0))\n\t\t) {\n\t\t\tevData.yCrossOver = !evData.yCrossOver;\n\t\t}\n\n\t\tconst swapXOrd = evData.xCrossOver !== evData.startXCrossOver;\n\t\tconst swapYOrd = evData.yCrossOver !== evData.startYCrossOver;\n\n\t\tevData.inversedXOrd = swapXOrd ? inverseOrd(evData.ord) : false;\n\t\tevData.inversedYOrd = swapYOrd ? inverseOrd(evData.ord) : false;\n\t}\n\n\trender() {\n\t\tconst {\n\t\t\tchildren,\n\t\t\tclassName,\n\t\t\tcrossorigin,\n\t\t\tcrop,\n\t\t\tdisabled,\n\t\t\tlocked,\n\t\t\timageAlt,\n\t\t\tonImageError,\n\t\t\trenderComponent,\n\t\t\tsrc,\n\t\t\tstyle,\n\t\t\timageStyle,\n\t\t\truleOfThirds,\n\t\t} = this.props;\n\n\t\tconst { cropIsActive, newCropIsBeingDrawn } = this.state;\n\n\t\tconst cropSelection =\n\t\t\tisCropValid(crop) && this.componentRef\n\t\t\t\t? this.createCropSelection()\n\t\t\t\t: null;\n\n\t\tconst componentClasses = clsx('ReactCrop', className, {\n\t\t\t'ReactCrop--active': cropIsActive,\n\t\t\t'ReactCrop--disabled': disabled,\n\t\t\t'ReactCrop--locked': locked,\n\t\t\t'ReactCrop--new-crop': newCropIsBeingDrawn,\n\t\t\t// In this case we have to shadow the image, since the box-shadow on the crop won't work.\n\t\t\t'ReactCrop--crop-invisible':\n\t\t\t\tcrop && cropIsActive && (!crop.width || !crop.height),\n\t\t\t'ReactCrop--rule-of-thirds': crop && ruleOfThirds,\n\t\t});\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={n => {\n\t\t\t\t\tthis.componentRef = n;\n\t\t\t\t}}\n\t\t\t\tclassName={componentClasses}\n\t\t\t\tstyle={style}\n\t\t\t\tonMouseDown={this.onComponentMouseDown}\n\t\t\t\ttabIndex='0'>\n\t\t\t\t<div ref={n => (this.mediaWrapperRef = n)}>\n\t\t\t\t\t{renderComponent || (\n\t\t\t\t\t\t<CropImageWrapper\n\t\t\t\t\t\t\tref={r => (this.imageRef = r)}\n\t\t\t\t\t\t\tcrossOrigin={crossorigin}\n\t\t\t\t\t\t\tstyle={imageStyle}\n\t\t\t\t\t\t\tsrc={src}\n\t\t\t\t\t\t\tonLoad={e => this.onImageLoad(e.target)}\n\t\t\t\t\t\t\tonError={onImageError}\n\t\t\t\t\t\t\talt={imageAlt}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t{children}\n\t\t\t\t{cropSelection}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nReactCrop.xOrds = ['e', 'w'];\nReactCrop.yOrds = ['n', 's'];\nReactCrop.xyOrds = ['nw', 'ne', 'se', 'sw'];\n\nReactCrop.nudgeStep = 0.2;\nReactCrop.nudgeStepLarge = 2;\n\nReactCrop.defaultCrop = {\n\tx: 0,\n\ty: 0,\n\twidth: 0,\n\theight: 0,\n\tunit: 'px',\n};\n\nReactCrop.propTypes = {\n\tclassName: PropTypes.string,\n\tchildren: PropTypes.oneOfType([\n\t\tPropTypes.arrayOf(PropTypes.node),\n\t\tPropTypes.node,\n\t]),\n\tcircularCrop: PropTypes.bool,\n\tcrop: PropTypes.shape({\n\t\taspect: PropTypes.number,\n\t\tx: PropTypes.number,\n\t\ty: PropTypes.number,\n\t\twidth: PropTypes.number,\n\t\theight: PropTypes.number,\n\t\tunit: PropTypes.oneOf(['px', '%']),\n\t}),\n\tcrossorigin: PropTypes.string,\n\tdisabled: PropTypes.bool,\n\tlocked: PropTypes.bool,\n\timageAlt: PropTypes.string,\n\timageStyle: PropTypes.shape({}),\n\tkeepSelection: PropTypes.bool,\n\tminWidth: PropTypes.number,\n\tminHeight: PropTypes.number,\n\tmaxWidth: PropTypes.number,\n\tmaxHeight: PropTypes.number,\n\tonChange: PropTypes.func.isRequired,\n\tonImageError: PropTypes.func,\n\tonComplete: PropTypes.func,\n\tonImageLoaded: PropTypes.func,\n\tonDragStart: PropTypes.func,\n\tonDragEnd: PropTypes.func,\n\tsrc: PropTypes.string.isRequired,\n\tstyle: PropTypes.shape({}),\n\trenderComponent: PropTypes.node,\n\trenderSelectionAddon: PropTypes.func,\n\truleOfThirds: PropTypes.bool,\n};\n\nReactCrop.defaultProps = {\n\tcircularCrop: false,\n\tclassName: undefined,\n\tcrop: undefined,\n\tcrossorigin: undefined,\n\tdisabled: false,\n\tlocked: false,\n\timageAlt: '',\n\tmaxWidth: undefined,\n\tmaxHeight: undefined,\n\tminWidth: 0,\n\tminHeight: 0,\n\tkeepSelection: false,\n\tonComplete: () => {},\n\tonImageError: () => {},\n\tonImageLoaded: () => {},\n\tonDragStart: () => {},\n\tonDragEnd: () => {},\n\tchildren: undefined,\n\tstyle: undefined,\n\trenderComponent: undefined,\n\timageStyle: undefined,\n\trenderSelectionAddon: undefined,\n\truleOfThirds: false,\n};\n\nexport { ReactCrop as default, ReactCrop as Component, containCrop };\n","import ReactDOM from 'react-dom';\nimport React, { PureComponent } from 'react';\nimport ReactCrop from './image-crop';\nimport './image-crop.css';\n\nimport './App.css';\n\nclass App extends PureComponent {\n\tstate = {\n\t\tsrc: null,\n\t\tcrop: {\n\t\t\t// unit: '%',\n\t\t\t// width: 30,\n\t\t\t// aspect: 16 / 9,\n\t\t},\n\t};\n\n\tonSelectFile = e => {\n\t\tif (e.target.files && e.target.files.length > 0) {\n\t\t\tconst reader = new FileReader();\n\t\t\treader.addEventListener('load', () =>\n\t\t\t\tthis.setState({ src: reader.result })\n\t\t\t);\n\t\t\treader.readAsDataURL(e.target.files[0]);\n\t\t}\n\t};\n\n\t// If you setState the crop in here you should return false.\n\tonImageLoaded = image => {\n\t\tthis.imageRef = image;\n\t};\n\n\tonCropComplete = crop => {\n\t\tthis.makeClientCrop(crop);\n\t};\n\n\tonCropChange = (crop, percentCrop) => {\n\t\t// You could also use percentCrop:\n\t\t// this.setState({ crop: percentCrop });\n\t\tthis.setState({ crop });\n\t};\n\n\tasync makeClientCrop(crop) {\n\t\tif (this.imageRef && crop.width && crop.height) {\n\t\t\tconst croppedImageUrl = await this.getCroppedImg(\n\t\t\t\tthis.imageRef,\n\t\t\t\tcrop,\n\t\t\t\t'newFile.jpeg'\n\t\t\t);\n\t\t\tthis.setState({ croppedImageUrl });\n\t\t}\n\t}\n\n\tgetCroppedImg(image, crop, fileName) {\n\t\tconst canvas = document.createElement('canvas');\n\t\tconst scaleX = image.naturalWidth / image.width;\n\t\tconst scaleY = image.naturalHeight / image.height;\n\t\tcanvas.width = crop.width;\n\t\tcanvas.height = crop.height;\n\t\tconst ctx = canvas.getContext('2d');\n\n\t\tctx.drawImage(\n\t\t\timage,\n\t\t\tcrop.x * scaleX,\n\t\t\tcrop.y * scaleY,\n\t\t\tcrop.width * scaleX,\n\t\t\tcrop.height * scaleY,\n\t\t\t0,\n\t\t\t0,\n\t\t\tcrop.width,\n\t\t\tcrop.height\n\t\t);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tcanvas.toBlob(blob => {\n\t\t\t\tif (!blob) {\n\t\t\t\t\t//reject(new Error('Canvas is empty'));\n\t\t\t\t\tconsole.error('Canvas is empty');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tblob.name = fileName;\n\t\t\t\twindow.URL.revokeObjectURL(this.fileUrl);\n\t\t\t\tthis.fileUrl = window.URL.createObjectURL(blob);\n\t\t\t\tresolve(this.fileUrl);\n\t\t\t}, 'image/jpeg');\n\t\t});\n\t}\n\n\trender() {\n\t\tconst { crop, croppedImageUrl, src } = this.state;\n\n\t\treturn (\n\t\t\t<div className='App'>\n\t\t\t\t<div>\n\t\t\t\t\t<input type='file' accept='image/*' onChange={this.onSelectFile} />\n\t\t\t\t</div>\n\t\t\t\t{src && (\n\t\t\t\t\t<ReactCrop\n\t\t\t\t\t\tsrc={src}\n\t\t\t\t\t\tcrop={crop}\n\t\t\t\t\t\truleOfThirds\n\t\t\t\t\t\tonImageLoaded={this.onImageLoaded}\n\t\t\t\t\t\tonComplete={this.onCropComplete}\n\t\t\t\t\t\tonChange={this.onCropChange}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{croppedImageUrl && (\n\t\t\t\t\t<img alt='Crop' style={{ maxWidth: '100%' }} src={croppedImageUrl} />\n\t\t\t\t)}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}